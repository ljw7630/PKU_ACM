//比如 6的 (6), (1 4 1), (2 2 2), (1 1 2 1 1), (3 3), (1 2 2 1), ( 1 1 1 1 1 1) 一共7个。将6拆成两个相同的数和另一个大于这个数的数或者0（真拗口）。直接看下面就好：
//1、6=1+1+4。那么他可以将4的所有情况两边都加1变成6的解 (1 4 1), (1 1 2 1 1), (1 2 2 1), ( 1 1 1 1 1 1)共4个。
//2、6=2+2+2。那么他可以将2的所有最小值大于等于2的情况两边加2 即将（2） 变成 （2，2，2） 共1个
//3、6=3+3+0。注意只有另一个数是0的时候才可以这么拆 如 5= 2+2+1 是不可以的。那么他可以将0 的所有情况两边加3，变成3，3 共1个。这里默认0的情况总数是1.
//4、6本身自己 （6） 就是一组 共1个
//所以 6的解共4+1+1+1=7个。
//由以上分析得到状态转移方程 s[i][j] = s[i-2*j][j] + s[i][j+1];(1<=j<=i/2)
//其中i表示数据的和，就是题中的n，j表示i的所有解中所有数大于等于j的情况总数（之所以这样定义可以参考上面分析中的第2步）
//具体实现
//1、将s[i][j] (i>=j>i/2) 内容预处理成1（因为对于j>i/2时 所有的s[i][j]都是1，如s[6][4]=s[6][5]=s[6][6]=1 只有（6）一个）。
//2、将s[i][j] (i<j) 内容预处理成0 （因为根据定义j不可能比i大。）
//3、将s[0][j]  内容预处理成1 （因为当需要调用s[0][j]时表示一个数拆成了完全相同的两个数，结果当然是一个了，）
//4、在for (i=2;i<=nax;i++)的每次循环中加入for (j=i/2;j>=1;j--)循环，每次逆推结果
//

#include <iostream>
using namespace std;
int n;
__int64 s[301][301];
int main()
{
	int i,j;
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	
	for(i=1;i<=300;i++)
		for(j=i;j>=0;j--)
			s[i][j]=1;
	for(i=0;i<=300;i++)
		s[0][i]=1;
	for(i=2;i<=300;i++)
		for(j=i/2;j>=1;j--)
			s[i][j]=s[i-2*j][j]+s[i][j+1];

	while(scanf("%d",&n)!=EOF&&n!=0)
	{
		printf("%d %I64d\n",n,s[n][1]);
	}
	return 0;
}